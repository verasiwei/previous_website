<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[How to do Annotation]]></title>
    <url>%2F2018%2F10%2F30%2FHow-to-do-Annotation%2F</url>
    <content type="text"><![CDATA[Use ANNOVAR to annotate the SNPs. Prepare the ANNOVAR input file: vcf format or .avinput formatNotice: In vcf file, the reference allele column and alternative allele column is actually the major allele and minor allele, but major allele are not always the reference allele. So use R package to figure out the correct reference allele in hg19 at first. Example: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#Do the annotationsource(&quot;https://bioconductor.org/biocLite.R&quot;)#biocLite(&quot;GenomicRanges&quot;)biocLite(&quot;BSgenome&quot;)biocLite(&quot;BSgenome.Hsapiens.UCSC.hg19&quot;)library(BSgenome.Hsapiens.UCSC.hg19)#BSgenome.Hsapiens.UCSC.hg19#overviewgenome &lt;- BSgenome.Hsapiens.UCSC.hg19seqlengths(genome)seqnames(genome)Hsapiens$chr2#read in significant snp information file#library(pegas)#vcf=read.vcf(&quot;sigsnpsvcf.vcf&quot;)snpinfo=read.table(&quot;sigsnps.bim&quot;,header = FALSE,sep=&quot;\t&quot;)colnames(snpinfo)=c(&quot;CHR&quot;,&quot;SNP&quot;,&quot;Unknown&quot;,&quot;BP&quot;,&quot;Minor&quot;,&quot;Major&quot;)#to get the reference allelechrs = seqnames(Hsapiens)[1:21]sigsnpref=c()k=1for (i in 1:21) &#123; for (j in k:(k+nrow(snpinfo[which(snpinfo$CHR==i),])-1) ) &#123; sigsnpref = c(sigsnpref,as.character(getSeq(Hsapiens, names=chrs[i], start=snpinfo[j,&quot;BP&quot;], end=snpinfo[j,&quot;BP&quot;]))) &#125; k=k+nrow(snpinfo[which(snpinfo$CHR==i),])&#125;sigsnpref.dat=data.frame(sigsnpref)snpinfo$ref=sigsnpref.dat$sigsnprefsnpinfo$Minor=as.character(snpinfo$Minor)snpinfo$Major=as.character(snpinfo$Major)snpinfo$ref=as.character(snpinfo$ref)#check unmatchsnpinfo[which((snpinfo$Major)!=(snpinfo$ref)),&quot;Minor&quot;]=snpinfo[which((snpinfo$Major)!=(snpinfo$ref)),&quot;Major&quot;]snpinfo$Major=snpinfo$refsnpinfo=snpinfo[,c(1:6)]write.table(snpinfo,&quot;sigsnps.bim&quot;,row.names = FALSE,col.names=FALSE,sep = &quot;\t&quot;,quote = FALSE)#prepare the .avinput file snpinfo$SNP=snpinfo$BPsnpinfo$Unknown=snpinfo$BPsnpinfo$Alt=snpinfo$Minorsnpinfo=snpinfo[,c(1,2,3,6,7)]colnames(snpinfo)=c(&quot;CHR&quot;,&quot;Start&quot;,&quot;End&quot;,&quot;Ref&quot;,&quot;Alt&quot;)write.table(snpinfo,&quot;sigsnps.avinput&quot;,row.names = FALSE,col.names=FALSE,sep = &quot;\t&quot;,quote = FALSE) #annotation=read.table(&quot;sigannotation5*10^-5.hg19_multianno.txt&quot;,header = TRUE,sep = &quot;\t&quot;, # c(&quot;Chr&quot;,&quot;Start&quot;,&quot;End&quot;,&quot;Ref&quot;,&quot;Alt&quot;,&quot;Func.refGene&quot;,&quot;Gene.refGene&quot;,&quot;GeneDetail.refGene&quot;,&quot;ExonicFunc.refGene&quot;,&quot;AAChange.refGene&quot;)) annotation=read.csv(&quot;sigannotation2.hg19_multianno.csv&quot;,header = TRUE) annotation$BP=annotation$Start colnames(annotation)[1]=&quot;CHR&quot; sigsnps=read.csv(&quot;unilog_4covs_ph.csv&quot;,header = TRUE) combine_annotation=merge(sigsnps,annotation,by.x=c(&quot;CHR&quot;,&quot;BP&quot;),by.y=c(&quot;CHR&quot;,&quot;BP&quot;),sort = FALSE) write.table(combine_annotation,&quot;result_table.csv&quot;,sep = &quot;,&quot;,row.names = FALSE,col.names = TRUE,quote = FALSE) use plink plink --bfile filename --recode vcf --out filename to convert to vcf format, then download the database 123456789annotate_variation.pl -buildver hg19 -downdb -webfrom annovar refGene humandb/annotate_variation.pl -buildver hg19 -downdb cytoBand humandb/annotate_variation.pl -buildver hg19 -downdb -webfrom annovar exac03 humandb/ annotate_variation.pl -buildver hg19 -downdb -webfrom annovar avsnp147 humandb/ annotate_variation.pl -buildver hg19 -downdb -webfrom annovar dbnsfp30a humandb/ Then using table_annovar.pl to annotate in one step: 123table_annovar.pl vcffile --buildver hg19 -out outfilename -remove -protocol refGene,cytoBand,exac03,avsnp147,dbnsfp30a -operation g,r,f,f,f -nastring . -vcfinputtable_annovar.pl .avinputfile -buildver hg19 -out outfilename -remove -protocol refGene,cytoBand,exac03,avsnp147,dbnsfp30a -operation g,r,f,f,f -nastring . -csvout -polish -xref gene_reffile If using annotate_variation.pl to apply only gene based annotation 1perl annotate_variation.pl --geneanno -dbtype refGene -out outfilename -build hg19 avinputfile directory_refgene]]></content>
      <categories>
        <category>Bioinformatics</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[master thesis]]></title>
    <url>%2F2018%2F10%2F29%2Fmaster-thesis%2F</url>
    <content type="text"><![CDATA[This is not teamwork project, this is my master thesis.]]></content>
      <categories>
        <category>My Teamwork Projects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mushroom prediction]]></title>
    <url>%2F2018%2F10%2F29%2Fmushroom-prediction%2F</url>
    <content type="text"><![CDATA[It was the final project of machine learning course. The method is very normal machine learning model. But I really think it is a good practice to build up shiny app, which is a very convenient way to present the model and results for those who do not have any backgroud of html or building up a website. The attached link is the teamwork of my team. https://ritujingyisiwei.shinyapps.io/final_mushroom/]]></content>
      <categories>
        <category>My Teamwork Projects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ggplot cheat sheet]]></title>
    <url>%2F2018%2F10%2F27%2Fggplot-cheat-sheet%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129ggplot(data=NULL,mapping=aes(x=,y=,color=,),environment=parent.frame())## one variable:ggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,linetype=,size=,))+geom_area(aes(y=..density..),stat=�bin�) #with shadowggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,linetype=,size=,weight=))+geom_density(aes(y=..county..,),kernel=�gaussian�) #without shadowggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,))++geom_dotplot()#plot dotsggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,linetype=,size=,weight-))++geom_histogram(aes(y=..density..),binwidth=5)## two variables### continuous X, continuous Yggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,shape=,size=,))+geom_jitter() #jittering is adding a small amount of random noise to data, it is often used to spread out points that would otherwisebe overplottedggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,shape=,size=,))+geom_point()ggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,linetype=,size=,weight=))+geom_quantile()ggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,lintype=,size=,))+geom_rug(sides=�bl�)ggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,linetype=,size=,weight=))+geom_smooth(model=lm)ggplot(data=NULL,mapping=aes(x=,y=,label=,alpha=,angle=,color=,family=,fontface=,hjust=,lineheight=,size=,vjust=))+geom_text(aes(label=cty))###continuous bivariate distributionggplot(data=NULL,mapping=aes(xmax=,xmin=,ymax=,ymin=,alpha=,color=,fill=,linetype=,size=,weight=))+geom_bin2d()ggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,linetype=,size=,))+geom_density2d()ggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,size=,))+geom_hex()###discrete X, continuous Yggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,lintype=,size=,weight=))+geom_bar(stat=�identity�)ggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=,shape=,size=,))+geom_boxplot(lower=,middle=,upper=,x=,ymax=,ymin=,alpha=,color=,fill=,linetype=,shape=,size=,weight=)ggplot(data=NULL,mapping=aes(x=,y=,alpha=,color=,fill=))+geom_dotplot(binaxis=�y�,stackdir=�center�)##visualizing errorggplot(data=NULL,aes(x=,y=,ymin=,ymax=,alpha=,color=,fill=,linetype=,size=))+geom_crossbar(fatten=2)ggplot(data=NULL,aes(x=,ymin=,ymax=,alpha=,color=,linetype=,size=,width=))+geom_errorbar()ggplot(data=NULL,aes(x=,ymin=,ymax=,alpha=,color=,linetype=,size=))+geom_linerange()ggplot(data=NULL,aes(x=,y=,ymin=,ymax=,alpha=,color=,fill=,linetype=,shape=,size=))+geom_pointrange()##Stats:some plots visualize a transformation of the original data set, each stats creates additional variables to map aesthetics tostat_smooth(method=��,formula=)method: datasets with n&lt;1000, use loess, n&gt;1000, use gamhow to define smooths in gam formulae???s(�,k=1,fx=FALSE,bs=�tp�)� represents a list of variables that are the covariates that this smooth is a function ofk is the dimension of the basis used to represent the smooth termfx is whether the term is a fixed d.f. regression splinebs is a two letter charater string indicating the penalized smoothing basis(smooth terms in GAM)thin plate regression spline: tp;duchon splines: dscubic regression splines: cr,cs,ccsplines on the sphere: sosP-splines: psRandom effects: reMarkov Random Fields: mrfGaussian process smooths: gpsoap film smooths: so, sf, swthin plate regression splines gives the best MSE performance but slower, the knot based penalized cubic regression splines is the secondbesthttps://www.rdocumentation.org/packages/mgcv/versions/1.8-24/topics/smooth.terms##Scalesscales control how a plot maps data values to the visual values of an aestheticscale_fill_manual(values=c(),limits=c(),breaks=c(),name=��,labels=c())specify the own set of mappings from levels in the data to aesthetic values;scale_x_continuous():set the range and the breaks for xaxis, map x values to visual valuesscale_color_manual():mapped colors for values##themestheme_bw():a theme with white background and black gridlinestheme():theme(axis.text.x=element_text(size= , angle= , hjust= ):when there are many x axis coordinates, a big issue is that they will be overlapped, so change the angle of x axis coordinates and horizontal justification##Facetingdivide a plot into subplots based on the values of one or more discrete variablesfacet_wrap(~fl): wraps a 1d sequence of panels into 2d(wrap facets into a rectangular layout)##Legendsplace legend at �bottom�,�top�,�left�, or �right�ggplot()+geom_point()+theme(legend.position)ggplot()+geom_point()+guides(color=�none�)ggplot()+geom_point()+scale_fill_discrete(name=�Title�,labels=c(�A�,�B�,�C�))#some other functions not related to ggplotgsub(): replaces all matches of a stringwith(): for example, with(mtcars,summary(mpg)) �&gt; to calculate the summary statistics of mpg in mtcars data, return the summary statisticcut():cut into different intervalsmelt():transform the wide format to long format; when does it need to transform to long format? when there are group factorssubset():subset datas of what you are interested in]]></content>
      <categories>
        <category>Programming</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[apply functions in R]]></title>
    <url>%2F2018%2F10%2F27%2Fapply-functions-in-R%2F</url>
    <content type="text"><![CDATA[It takes a lot of time to run for loop, apply function is different and based on C language, which saves a lot of time. #apply family ##apply ##lapply ##sapply ##vapply ##mapply ##tapply ##rapply ##eapply 123456789101112131415161718192021222324252627282930tapply; applymapplylapply�&gt;sapply�&gt;vapply�&gt;rapplyeapply#applyapply() can be applied to matrix, dataframe, arrayapply(X,MARGIN,FUN,�), X: dataframe,matrix,array; MARGIN: applied to rows when =1, applied to columns when =2; FUN: function that apply to the data#lapplyapply a given function to every element of a list and obtain a list as result, it can be applied to dataframes, lists or vectors, the outputreturn to a listlapply(X,FUN,�)lapply cannot be applied to vector or matrix#sapplysimilar to lapply, but return to vector, not listsapply(X,FUN,�,simplify=TRUE,USE.NAMES=TRUE)X can be array, matrix, dataframesimplify: whether to arrayUSE.NAMES: if X is a string, then TRUE set string as the data nameif simplify=FALSE and USE.NAMES=FALSE, then sapply is equal to lapplyif simplify=�array� then can create matrixesif USE.NAMES=TRUE, then can create data name#vapplyit is similar to sapplyvapply(X,FUN,FUN.VALUE,�,USE.NAMES=TRUE)]]></content>
      <categories>
        <category>Programming</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Beta Mixture]]></title>
    <url>%2F2018%2F10%2F26%2FBeta-Mixture%2F</url>
    <content type="text"><![CDATA[I focused on mixture model last month, but unluckily this model did not fit very well for our data and the robust estimation is much more stable. But I still made some summary for the algorithm of beta mixture model. Click on the attached link below. Beta Mixture Model]]></content>
      <categories>
        <category>Statistics &amp; Algorithms</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Topic Model in EMR project]]></title>
    <url>%2F2018%2F10%2F26%2FTopic-Model-in-EMR-project%2F</url>
    <content type="text"><![CDATA[I did this project during my summer intern in 2017 at Duke. It was the first time I got the knowledge of Electronic Medical Record and ICD-9 codes. We focused on Duke Medical Center Electronic Medical Records from 2004 to 2013 of 210,329 patients with 10,804 unique ICD9 diagnosis codes records for each patient. The algorithm I used is the supervised Latent Dirichlet Allocation(supvised topic model). The attached is the poster of this project. This browser does not support PDFs. Please download the PDF to view it: Download PDF.]]></content>
      <categories>
        <category>My Teamwork Projects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Generalized Additive Model]]></title>
    <url>%2F2018%2F10%2F26%2FGeneralized-Additive-Model%2F</url>
    <content type="text"><![CDATA[The linear relationship between response y and varaibles x is replaced by the non-linear smooth functions.]]></content>
      <categories>
        <category>Statistics &amp; Algorithms</category>
      </categories>
  </entry>
</search>
